<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="libco,">










<meta name="description" content="上篇已经介绍了libco切入切出的相关代码与流程，本文主要学习协程切换时寄存器以及运行时栈的变化，也会涉及扩展部分的相关内容：共享栈，协程控制，协程池。另外本文并非完全原创，多处代码解释参考某大佬KM文章，有的代码细节还没有看懂，也有的地方加入了自己的看法与见解。">
<meta name="keywords" content="libco">
<meta property="og:type" content="article">
<meta property="og:title" content="libco协程库学习笔记（二）（未完结）">
<meta property="og:url" content="www.chenghuili.cn/2020/12/30/libco协程库学习笔记（二）/index.html">
<meta property="og:site_name" content="lichenghui&#39;s blog">
<meta property="og:description" content="上篇已经介绍了libco切入切出的相关代码与流程，本文主要学习协程切换时寄存器以及运行时栈的变化，也会涉及扩展部分的相关内容：共享栈，协程控制，协程池。另外本文并非完全原创，多处代码解释参考某大佬KM文章，有的代码细节还没有看懂，也有的地方加入了自己的看法与见解。">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://raw.githubusercontent.com/chenghui-li/blog-photos/master/%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98/%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://raw.githubusercontent.com/chenghui-li/blog-photos/master/%E7%BA%BF%E7%A8%8B/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88.jpg">
<meta property="og:updated_time" content="2021-03-19T02:01:32.255Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="libco协程库学习笔记（二）（未完结）">
<meta name="twitter:description" content="上篇已经介绍了libco切入切出的相关代码与流程，本文主要学习协程切换时寄存器以及运行时栈的变化，也会涉及扩展部分的相关内容：共享栈，协程控制，协程池。另外本文并非完全原创，多处代码解释参考某大佬KM文章，有的代码细节还没有看懂，也有的地方加入了自己的看法与见解。">
<meta name="twitter:image" content="https://raw.githubusercontent.com/chenghui-li/blog-photos/master/%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98/%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="www.chenghuili.cn/2020/12/30/libco协程库学习笔记（二）/">





  <title>libco协程库学习笔记（二）（未完结） | lichenghui's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">lichenghui's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Pursue excellence, and success will follow!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="www.chenghuili.cn/2020/12/30/libco协程库学习笔记（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lichenghui">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/img/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lichenghui's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">libco协程库学习笔记（二）（未完结）</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-12-30T22:32:41+08:00">
                2020-12-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2020/12/30/libco协程库学习笔记（二）/" class="leancloud_visitors" data-flag-title="libco协程库学习笔记（二）（未完结）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>上篇已经介绍了libco切入切出的相关代码与流程，本文主要学习协程切换时寄存器以及运行时栈的变化，也会涉及扩展部分的相关内容：共享栈，协程控制，协程池。另外本文并非完全原创，多处代码解释参考<a href="http://km.oa.com/group/21362/articles/show/382180?kmref=search&amp;from_page=1&amp;no=2" target="_blank" rel="noopener">某大佬KM文章</a>，有的代码细节还没有看懂，也有的地方加入了自己的看法与见解。</p>
<a id="more"></a>
<p>首先复习下进程的地址空间。</p>
<p><img src="https://raw.githubusercontent.com/chenghui-li/blog-photos/master/%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98/%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt></p>
<p>与协程相关的有代码段，堆，栈。代码段包含应用程序的汇编代码，指令寄存器eip存的是代码段中某一条汇编指令地址，cpu从eip中取出汇编指令的地址，并在代码段中找到对应汇编指令开始执行。cpu执行指令时在栈里存参数、局部变量等数据。代码通过malloc和new在堆中申请内存空间。</p>
<p>libco协程可以分为主协程和其他协程，主协程即当前线程，区别在于<strong>主协程的栈在进程空间的栈区，而其他协程的栈在堆区</strong>。正常的函数调用都发生在栈区，esp和ebp都在栈区波动，可以看出协程中的esp和ebp会跳到堆区。协程的切换上一篇已经介绍过了，resume切到某个协程，实质上就是将目标协程栈（堆）里保存的寄存器的值放到寄存器里，当前寄存器里的值保存到即将被挂起的协程栈里，然后改变运行时栈（修改esp，eip）来改变运行时序。</p>
<p>这里的协程切换详细说下，不过在此之前先介绍下函数调用时的堆栈状态更有助于理解libco里汇编描述的切换的过程。其实函数调用的汇编有一个框架：<br>call func -&gt;  enter  -&gt; …  -&gt; leave  -&gt; ret<br>这样好像看不出什么，但是如果把这些指令展开就可以看出<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span>  = <span class="keyword">push</span> <span class="built_in">eip</span></span><br><span class="line">        <span class="keyword">jmp</span> func</span><br><span class="line"></span><br><span class="line"><span class="keyword">enter</span> = <span class="keyword">push</span> <span class="built_in">ebp</span></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">esp</span> <span class="built_in">ebp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">leave</span> = <span class="keyword">mov</span> <span class="built_in">ebp</span> <span class="built_in">esp</span></span><br><span class="line">        <span class="keyword">pop</span> <span class="built_in">ebp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ret</span>   = <span class="keyword">pop</span> <span class="built_in">eip</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/chenghui-li/blog-photos/master/%E7%BA%BF%E7%A8%8B/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88.jpg" alt><br>call与ret成对出现，enter与leave成对出现，一通操作后栈一切都恢复了调用前的原样。从这个角度出发，如果不让这些指令成对出现，自己去改变esp，ebp以及eip就可以实现从函数的任意位置切出去执行另一个函数的任意位置，然后再切回来。这里我们放大看一下libco的协程切换中esp，ebp，eip的改变：<br><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">coctx_swap:</span><br><span class="line">	<span class="comment">//此时要从当前运行的协程curr切换到目的协程pending_co</span></span><br><span class="line">	<span class="comment">//此时esp存储的是返回地址，即coctx_swap后面的代码编译后的第一条汇编指令地址stCoRoutineEnv_t* curr_env = co_get_curr_thread_env();</span></span><br><span class="line">	<span class="comment">//esp+4为curr-&gt;ctx的地址，也是curr-&gt;ctx.regs的地址，因为regs是ctx中第一个元素</span></span><br><span class="line">	<span class="comment">//esp+8为pending_co-&gt;ctx的地址，也是pending_co-&gt;ctx.regs的地址，理由同上</span></span><br><span class="line">#<span class="keyword">if</span> defined(__i386__)</span><br><span class="line">	<span class="comment">//leal取地址，将esp+4的地址存到eax,为什么要用leal而不是mov呢，因为这里要存储地址，使用mov就会存储该地址的值</span></span><br><span class="line">	leal <span class="number">4</span>(<span class="built_in">%esp</span>), <span class="built_in">%eax</span> <span class="comment">//sp </span></span><br><span class="line">	<span class="comment">//将esp指向了curr-&gt;ctx.regs的地址，注意此时已经不是在co_swap函数栈中了，已经切到了curr-&gt;ctx.regs位置</span></span><br><span class="line">	movl <span class="number">4</span>(<span class="built_in">%esp</span>), <span class="built_in">%esp</span> </span><br><span class="line">	<span class="comment">//i386有void *regs[ 8 ]，所以挪动4*8个地址，而且这里是leal，地址加操作，所以还可以得出一个有用的结论：</span></span><br><span class="line">	<span class="comment">//对象内部成员先出现的在低地址，对象的地址最低，也是第一个成员的地址</span></span><br><span class="line">	leal <span class="number">32</span>(<span class="built_in">%esp</span>), <span class="built_in">%esp</span> <span class="comment">//parm a : &amp;regs[7] + sizeof(void*)</span></span><br><span class="line">	<span class="comment">//原esp+4地址入栈，当curr再恢复时作为curr的esp</span></span><br><span class="line">	pushl <span class="built_in">%eax</span> <span class="comment">//esp -&gt;parm a regs[7]: eax</span></span><br><span class="line"></span><br><span class="line">	pushl <span class="built_in">%ebp</span>  <span class="comment">//regs[6]: ebp</span></span><br><span class="line">	pushl <span class="built_in">%esi</span>  <span class="comment">//regs[5]: esi  </span></span><br><span class="line">	pushl <span class="built_in">%edi</span>  <span class="comment">//regs[4]: edi</span></span><br><span class="line">	pushl <span class="built_in">%edx</span>  <span class="comment">//regs[3]: edx</span></span><br><span class="line">	pushl <span class="built_in">%ecx</span>  <span class="comment">//regs[2]: ecx</span></span><br><span class="line">	pushl <span class="built_in">%ebx</span>  <span class="comment">//regs[1]: ebx</span></span><br><span class="line">	<span class="comment">//eax-4即原来的esp，也就是编译后的第一条汇编指令地址stCoRoutineEnv_t* curr_env = co_get_curr_thread_env();</span></span><br><span class="line">	<span class="comment">//当下一次该协程被唤醒时只需要将regs[0]保存的pop到eip中就可以从这次切出去的位置继续执行了</span></span><br><span class="line">	pushl -<span class="number">4</span>(<span class="built_in">%eax</span>)  <span class="comment">//regs[0]: ret</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//将esp指向了pending_co-&gt;ctx.regs的地址，注意此时已经不是在curr-&gt;ctx.regs中了，已经切到了pending_co-&gt;ctx.regs位置</span></span><br><span class="line">	movl <span class="number">4</span>(<span class="built_in">%eax</span>), <span class="built_in">%esp</span> <span class="comment">//parm b -&gt; &amp;regs[0]</span></span><br><span class="line">	<span class="comment">//从regs弹出返回地址，切到pending_co后pending_co需要执行的第一条指令地址</span></span><br><span class="line">	<span class="comment">//第一次切到pending_co返回地址是CoRoutineFunc函数的地址，co_create中设置的(regs[EIP]=pfn...)</span></span><br><span class="line">	<span class="comment">//第二次及以后切到pending_co返回地址是编译后的第一条汇编指令地址stCoRoutineEnv_t* curr_env = co_get_curr_thread_env();</span></span><br><span class="line">	popl <span class="built_in">%eax</span>  <span class="comment">//ret func addr //regs[0]: ret</span></span><br><span class="line">	popl <span class="built_in">%ebx</span>  <span class="comment">//regs[1]: ebx</span></span><br><span class="line">	popl <span class="built_in">%ecx</span>  <span class="comment">//regs[2]: ecx</span></span><br><span class="line">	popl <span class="built_in">%edx</span>  <span class="comment">//regs[3]: edx</span></span><br><span class="line">	popl <span class="built_in">%edi</span>  <span class="comment">//regs[4]: edi</span></span><br><span class="line">	popl <span class="built_in">%esi</span>  <span class="comment">//regs[5]: esi</span></span><br><span class="line">	popl <span class="built_in">%ebp</span>  <span class="comment">//regs[6]: ebp</span></span><br><span class="line">	<span class="comment">//弹出pending_co栈顶地址</span></span><br><span class="line">	<span class="comment">//第一次切到pending_co弹出的esp指向ctx-&gt;ss_sp + ctx-&gt;ss_size - sizeof(coctx_param_t) - sizeof(void*)</span></span><br><span class="line">	<span class="comment">//第二次及以后切到pending_co弹出的esp指向coctx_swap第一个参数所在栈的位置</span></span><br><span class="line">	popl <span class="built_in">%esp</span>  <span class="comment">//regs[7]: eax</span></span><br><span class="line">	<span class="comment">//这句和ret就是切换函数调用流程的灵魂，上面不是将上次挂起后/第一次运行的第一条指令地址存到eax中了么，</span></span><br><span class="line">	<span class="comment">//这里将这个地址push到pending_co的协程栈中，下面ret=pop eip就将这条指令地址放到了eip中，coctx_swap执行完毕，执行eip中的指令，函数调用流程完美切换。</span></span><br><span class="line">	pushl <span class="built_in">%eax</span> <span class="comment">//set ret func addr</span></span><br><span class="line">	<span class="comment">//eax清0</span></span><br><span class="line">	xorl <span class="built_in">%eax</span>, <span class="built_in">%eax</span></span><br><span class="line">	ret</span><br></pre></td></tr></table></figure></p>
<h1 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h1><p>每个协程在初始化时有一个stack_mem即运行时栈，如果是非共享栈则会分配128K的堆空间（后面所说的栈空间都是这个堆上），接下来协程运行过程中产生的临时变量、函数调用所有的都会在这个栈中分配。这样就会存在栈空间太大浪费或者空间不够用的情况。对于空间不够用可以多用new来新建临时变量，让其在堆中其他空间再分配，而不要分配到当前栈上。对于空间浪费问题就可以用共享栈来解决，共享栈仍然是在堆上，这对主协程没有影响，主协程的栈还在系统栈上。</p>
<p>采用共享栈时可以理解为协程切换以及运行中，esp和ebp都只在共享栈这块区域内变动，发生协程切换时需要把当前共享栈的状态保存到要被切出的协程的栈中。这样有个好处就是每个协程所持有的栈空间大小是按需分配的，自然会节省大量内存。同样带来的缺点就是协程切换时的栈拷贝，共享栈其实就是用时间换空间。</p>
<p>为了避免协程切换时频繁发生栈拷贝，可以申请多个共享栈。比如申请两个共享栈，协程运行顺序为协程1-&gt;协程2-&gt;协程1。如果用取模的方式来分配共享栈，那么协程1用栈1，切到协程2时协程2用栈2，栈1不用拷贝，再切回栈1时栈2也不用拷贝。当然寄存器每次发生协程切换都要有拷贝保存的操作（coctx_swap）<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">void co_swap(stCoRoutine_t* curr, stCoRoutine_t* pending_co)</span><br><span class="line">&#123;</span><br><span class="line"> 	stCoRoutineEnv_t* env = co_get_curr_thread_env();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//get curr stack sp</span></span><br><span class="line">	<span class="comment">//记录curr协程栈的位置，后面再切回curr协程时，将保存的curr协程栈内容拷贝到stack_sp所指的空间</span></span><br><span class="line">	char c;</span><br><span class="line">	<span class="function"><span class="title">curr</span>-&gt;</span>stack_sp= &amp;c;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">if</span> (!pending_co-&gt;</span>cIsShareStack)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="title">env</span>-&gt;</span>pending_co = NULL;</span><br><span class="line">		<span class="function"><span class="title">env</span>-&gt;</span>occupy_co = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="title">env</span>-&gt;</span>pending_co = pending_co;</span><br><span class="line">		<span class="comment">//get last occupy co on the same stack mem</span></span><br><span class="line">		<span class="comment">//获取要切到的协程将要使用的共享栈现在正在被哪个协程使用</span></span><br><span class="line">		<span class="function"><span class="title">stCoRoutine_t</span>* occupy_co = pending_co-&gt;</span><span class="function"><span class="title">stack_mem</span>-&gt;</span>occupy_co;</span><br><span class="line">		<span class="comment">//set pending co to occupy thest stack mem;</span></span><br><span class="line">		<span class="comment">//将那个共享栈记录修改为pending_co正在使用</span></span><br><span class="line">		<span class="function"><span class="title">pending_co</span>-&gt;</span><span class="function"><span class="title">stack_mem</span>-&gt;</span>occupy_co = pending_co;</span><br><span class="line">		<span class="comment">//在全局变量env中记录下那个共享栈被“霸占”的协程</span></span><br><span class="line">		<span class="comment">//不能记录在局部变量中，因为协程切换后curr协程中的内容不可以被pending_co读</span></span><br><span class="line">		<span class="function"><span class="title">env</span>-&gt;</span>occupy_co = occupy_co;</span><br><span class="line">		<span class="keyword">if</span> (occupy_co &amp;&amp; occupy_co != pending_co)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//occupy_co协程栈内容保存到save_buffer，从occupy-&gt;stack_sp（低地址）保存到occupy-&gt;stack_mem-&gt;stack_bp（高地址）</span></span><br><span class="line">			save_stack_buffer(occupy_co);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//swap context</span></span><br><span class="line">	<span class="comment">//保存curr寄存器内容，恢复pending寄存器内容，切换ebp，esp使其指向pending_co的协程栈</span></span><br><span class="line">	<span class="function"><span class="title">coctx_swap</span>(&amp;(curr-&gt;</span><span class="function"><span class="title">ctx</span>),&amp;(pending_co-&gt;</span>ctx) );</span><br><span class="line"></span><br><span class="line">	<span class="comment">//stack buffer may be overwrite, so get again;</span></span><br><span class="line">	<span class="comment">//此时运行的协程是pending_co，切到pending_co执行的第一条代码就是下面这条指令。</span></span><br><span class="line">	stCoRoutineEnv_t* curr_env = co_get_curr_thread_env();</span><br><span class="line">	<span class="function"><span class="title">stCoRoutine_t</span>* update_occupy_co =  curr_env-&gt;</span>occupy_co;</span><br><span class="line">	<span class="function"><span class="title">stCoRoutine_t</span>* update_pending_co = curr_env-&gt;</span>pending_co;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (update_occupy_co &amp;&amp; update_pending_co &amp;&amp; update_occupy_co != update_pending_co)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//resume stack buffer</span></span><br><span class="line">		<span class="comment">//如果pending_co第一次运行，save_buffer为空，不会执行下面的memcpy</span></span><br><span class="line">		<span class="function"><span class="title">if</span> (update_pending_co-&gt;</span><span class="function"><span class="title">save_buffer</span> &amp;&amp; update_pending_co-&gt;</span>save_size &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//pending_co之前切出时记录了栈低地址位置stack_sp=&amp;c</span></span><br><span class="line">			<span class="comment">//所以pending_co再切回时将保存的pending_co栈内容复制到stack_sp指向的空间</span></span><br><span class="line">			<span class="function"><span class="title">memcpy</span>(update_pending_co-&gt;</span><span class="function"><span class="title">stack_sp</span>, update_pending_co-&gt;</span><span class="function"><span class="title">save_buffer</span>, update_pending_co-&gt;</span>save_size);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="协程控制"><a href="#协程控制" class="headerlink" title="协程控制"></a>协程控制</h1><p>libco使用的是epoll多路复用IO模型，非阻塞IO，发起read/write操作后即可挂起协程，调度其他协程执行，等数据就绪后唤醒该协程继续执行。所以协程在写法上非常友好，不需要像异步IO那样定义回调函数，read/write完即可继续写后续的逻辑。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> read( <span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbyte )</span><br><span class="line">&#123;</span><br><span class="line">	HOOK_SYS_FUNC( read );</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>( !co_is_enable_sys_hook() )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> g_sys_read_func( fd,buf,nbyte );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">rpchook_t</span> *lp = get_by_fd( fd );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( !lp || ( O_NONBLOCK &amp; lp-&gt;user_flag ) ) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">ssize_t</span> ret = g_sys_read_func( fd,buf,nbyte );</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> timeout = ( lp-&gt;read_timeout.tv_sec * <span class="number">1000</span> ) </span><br><span class="line">				+ ( lp-&gt;read_timeout.tv_usec / <span class="number">1000</span> );</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pf</span> = &#123;</span> <span class="number">0</span> &#125;;</span><br><span class="line">	pf.fd = fd;</span><br><span class="line">	pf.events = ( POLLIN | POLLERR | POLLHUP );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> pollret = poll( &amp;pf,<span class="number">1</span>,timeout );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">ssize_t</span> readret = g_sys_read_func( fd,(<span class="keyword">char</span>*)buf ,nbyte );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( readret &lt; <span class="number">0</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		co_log_err(<span class="string">"CO_ERR: read fd %d ret %ld errno %d poll ret %d timeout %d"</span>,</span><br><span class="line">					fd,readret,errno,pollret,timeout);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> readret;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里是自定义的read函数hook住系统read函数，前面都是对其他情况的兼容，比如用户没有开启hook则直接调用系统read；如果指定了非阻塞也直接调用系统read，此时为非阻塞。重点在于调用poll挂起当前协程，直到有数据就绪或者超时时，协程才会被重新调度。<br>write也是类似的逻辑，不同之处在于read不知道要读多少字节，所以只读一次；而write知道要写多少字节，所以每次写如果没有全部写完，则需要重新加入到poll中直到写完/写出错才会停止<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> write( <span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbyte )</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">size_t</span> wrotelen = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>( wrotelen &lt; nbyte )</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pf</span> = &#123;</span> <span class="number">0</span> &#125;;</span><br><span class="line">		pf.fd = fd;</span><br><span class="line">		pf.events = ( POLLOUT | POLLERR | POLLHUP );</span><br><span class="line">		poll( &amp;pf,<span class="number">1</span>,timeout );</span><br><span class="line"></span><br><span class="line">		writeret = g_sys_write_func( fd,(<span class="keyword">const</span> <span class="keyword">char</span>*)buf + wrotelen,nbyte - wrotelen );</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>( writeret &lt;= <span class="number">0</span> )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		wrotelen += writeret ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (writeret &lt;= <span class="number">0</span> &amp;&amp; wrotelen == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> writeret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> wrotelen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>协程hook住了底层socket族函数（read，write，recv，send…），设置了O_NONBLOCK，调用socket族函数后，调用poll，此处的poll是自定义的poll，里面又调用了co_poll_inner，在该函数中创建了epoll描述符，设置就绪fd的回调函数OnPollProcessEvent来切回到对应协程，并记录切回协程之前需要做的一些预操作处理函数OnPollPreparePfn，然后加入epoll的红黑树和超时队列，挂起协程让其他协程执行，所有协程都挂起后通过eventloop在主协程里检查注册的IO事件，若就绪或超时则切到对应协程。<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">void co_eventloop( stCoEpoll_t *ctx,pfn_co_eventloop_t pfn,void *arg )</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">for</span>(;;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="title">int</span> ret = co_epoll_wait( ctx-&gt;</span>iEpollFd,result,stCoEpoll_t::_EPOLL_SIZE, <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="title">stTimeoutItemLink_t</span> *active = (ctx-&gt;</span>pstActiveList);</span><br><span class="line">		<span class="function"><span class="title">stTimeoutItemLink_t</span> *timeout = (ctx-&gt;</span>pstTimeoutList);</span><br><span class="line"></span><br><span class="line">		memset( timeout,<span class="number">0</span>,sizeof(stTimeoutItemLink_t) );</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;ret;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function"><span class="title">stTimeoutItem_t</span> *item = (stTimeoutItem_t*)result-&gt;</span>events[i].<span class="keyword">data</span>.ptr;</span><br><span class="line">			<span class="function"><span class="title">if</span>( item-&gt;</span>pfnPrepare )</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function"><span class="title">item</span>-&gt;</span><span class="function"><span class="title">pfnPrepare</span>( item,result-&gt;</span>events[i],active );</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				AddTail( active,item );</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		unsigned long long now = GetTickMS();</span><br><span class="line">		T<span class="function"><span class="title">akeAllTimeout</span>( ctx-&gt;</span>pTimeout,now,timeout );</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="title">stTimeoutItem_t</span> *lp = timeout-&gt;</span>head;</span><br><span class="line">		<span class="keyword">while</span>( lp )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//printf("raise timeout %p\n",lp);</span></span><br><span class="line">			<span class="function"><span class="title">lp</span>-&gt;</span>bTimeout = <span class="literal">true</span>;</span><br><span class="line">			<span class="function"><span class="title">lp</span> = lp-&gt;</span>pNext;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Join&lt;stTimeoutItem_t,stTimeoutItemLink_t&gt;( active,timeout );</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="title">lp</span> = active-&gt;</span>head;</span><br><span class="line">		<span class="keyword">while</span>( lp )</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			PopHead&lt;stTimeoutItem_t,stTimeoutItemLink_t&gt;( active );</span><br><span class="line">            <span class="function"><span class="title">if</span> (lp-&gt;</span><span class="function"><span class="title">bTimeout</span> &amp;&amp; now &lt; lp-&gt;</span>ullExpireTime) </span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function"><span class="title">int</span> ret = AddTimeout(ctx-&gt;</span>pTimeout, lp, now);</span><br><span class="line">				<span class="keyword">if</span> (!ret) </span><br><span class="line">				&#123;</span><br><span class="line">					<span class="function"><span class="title">lp</span>-&gt;</span>bTimeout = <span class="literal">false</span>;</span><br><span class="line">					<span class="function"><span class="title">lp</span> = active-&gt;</span>head;</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="function"><span class="title">if</span>( lp-&gt;</span>pfnProcess )</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function"><span class="title">lp</span>-&gt;</span>pfnProcess( lp );</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="function"><span class="title">lp</span> = active-&gt;</span>head;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>( pfn )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>( -<span class="number">1</span> == pfn( arg ) )</span><br><span class="line">			&#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述为主协程调用eventloop片段。首先用co_epoll_wait找出所有就绪的fd，将就绪fd从超时队列pTimeOut移除并加入到就绪队列pstActiveList。TakeAllTImeout拿出超时队列里的所有超时元素并加入到就绪队列pstActiveList。在遍历就绪队列时有一个是否超时的判断，没有超时的再重新加入到超时队列，因为TakeAllTImeout取出的不一定是真正的超时事件，超时队列底层实现是60000大小的循环数组，存放每毫秒（共60000毫秒）的超时事件，每个数组的元素均是一条链表，循环数组的目的是便于通过下标找到所有超时链表。例如超时时间是10毫秒的所有事件均记录在数组下标为9（在循环数组实际的下标可能不是9，仅举个例子）的链表里，所有超时时间大于60000毫秒的事件均记录在数组下标为59999的链表里。如果取出超时时间是60000毫秒的事件，TakeAllTimeout会把超时时间大于60000毫秒的也取出来，因此需要再把超时时间大于60000毫秒的重新加回超时队列。<br>事件超时或者就绪时调用pfnProcess即OnPollProcessEvent切回协程（该参数在调用poll中设置），此时协程是第k次（k&gt;1)次切回，从上次切出的地方继续执行（poll–&gt;co_yield_env–&gt;co_swap–&gt;stCoRoutineEnv_t* curr_env = co_get_curr_thread_env()）<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void OnPollProcessEvent( <span class="name">stTimeoutItem_t</span> * ap )</span><br><span class="line">&#123;</span><br><span class="line">	stCoRoutine_t *co = (<span class="name">stCoRoutine_t*</span>)ap-&gt;pArg<span class="comment">;</span></span><br><span class="line">	co_resume( <span class="name">co</span> )<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除了epoll激活协程外还可以使用超时来激活协程，可以调用poll(NULL, 0, duration)设置协程挂起duration秒后激活重新运行。poll是被hook住的函数，执行poll之后，当前协程会被加到超时队列pTimeOut，并被切换到其他协程，所有协程挂起后，主协程扫描超时队列，找到超时的协程，并切换。因此可用poll实现协程的睡眠。注意不可用sleep，因为sleep会睡眠线程，线程睡眠了，协程无法被调度，所有的协程也都不会执行了。</p>
<h1 id="协程池"><a href="#协程池" class="headerlink" title="协程池"></a>协程池</h1><p>协程池的好处是不用每次使用协程时都创建新的协程。创建新协程主要开销有两个：一，需要malloc协程环境stCoRoutine_t，stCoRoutine_t有4K大小的协程私有变量数组；二，协程栈128K。每次创建新的协程要分配这么大的空间需要有时间开销，另外频繁申请、销毁会导致内存碎片的产生。即使在共享栈模式下不用为每个协程申请协程栈，也会有第一部分stCoRoutine_t的开销。每次从协程池取出协程后，将stCoRoutine_t.pfn重新初始化为用户自定义的协程函数即可。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> void* worker_main(void* arg) &#123;</span><br><span class="line">  CWorker* worker = (CWorker*)arg;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (worker-&gt;func_) &#123;</span><br><span class="line">      worker-&gt;func_();</span><br><span class="line">    &#125;</span><br><span class="line">    worker-&gt;func_ = <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (g_worker_pool.gc_stack_size_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      FreeStackRss(worker-&gt;co_-&gt;stack_mem-&gt;stack_buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g_worker_pool.workers_.push(worker);</span><br><span class="line">    co_yield_ct();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ProcessByWorker(std::function&lt;void(void)&gt; func1) &#123;</span><br><span class="line">  CWorker* worker = <span class="keyword">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span> (g_worker_pool.workers_.<span class="keyword">empty</span>()) &#123;</span><br><span class="line">    stCoRoutineAttr_t attr;</span><br><span class="line">    attr.stack_size = g_worker_pool.hard_limit_stack_size_;</span><br><span class="line">    stCoRoutine_t* worker_routine = <span class="keyword">NULL</span>;</span><br><span class="line">    worker = <span class="keyword">new</span> CWorker(worker_routine);</span><br><span class="line">    co_create(&amp;worker_routine, &amp;attr, worker_main, worker);</span><br><span class="line">    worker-&gt;co_ = worker_routine;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    worker = g_worker_pool.workers_.top();</span><br><span class="line">    g_worker_pool.workers_.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (worker == <span class="keyword">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  worker-&gt;func_ = func1;</span><br><span class="line">  co_resume(worker-&gt;co_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>TODO list<br>1 libco的demo都学习下，出一篇博客<br>2 协程池学习procebyworker<br><a href="http://km.oa.com/group/492/articles/show/354520?kmref=search&amp;from_page=1&amp;no=1" target="_blank" rel="noopener">内网</a><br><a href="https://github.com/duxing2007/libco/blob/master/worker_pool.cpp" target="_blank" rel="noopener">github</a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://km.oa.com/group/21362/articles/show/382180?kmref=search&amp;from_page=1&amp;no=2" target="_blank" rel="noopener">某大佬KM文章</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/libco/" rel="tag"># libco</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/07/12/基于redis的分布式锁学习/" rel="next" title="基于redis的分布式锁学习">
                <i class="fa fa-chevron-left"></i> 基于redis的分布式锁学习
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/img/me.jpg" alt="lichenghui">
            
              <p class="site-author-name" itemprop="name">lichenghui</p>
              <p class="site-description motion-element" itemprop="description">stay foolish, stay hungry</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">80</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">83</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/chenghui-li" target="_blank" title="MyGitHub">
                    
                      <i class="fa fa-fw fa-globe"></i>MyGitHub</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#共享栈"><span class="nav-number">1.</span> <span class="nav-text">共享栈</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#协程控制"><span class="nav-number">2.</span> <span class="nav-text">协程控制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#协程池"><span class="nav-number">3.</span> <span class="nav-text">协程池</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考资料"><span class="nav-number">4.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lichenghui</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("c9YJ73tLzVPzWp36mrElO2Y2-gzGzoHsz", "JTQv2LjxM8U9KnMKLcUfNYaU");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
